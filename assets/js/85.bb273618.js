(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{369:function(e,t,_){"use strict";_.r(t);var v=_(10),n=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"opengl学习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#opengl学习"}},[e._v("#")]),e._v(" OpenGL学习")]),e._v(" "),t("p",[e._v("最好的OpenGL学习资料"),t("a",{attrs:{href:"https://learnopengl.com/Getting-started/OpenGL",target:"_blank",rel:"noopener noreferrer"}},[e._v("learnopengl"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/",target:"_blank",rel:"noopener noreferrer"}},[e._v("中文版地址"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("OpenGL是一组图形学接口，不同操作系统实现不同，具体的实现是由显卡制造商负责的，因此需要经常更新显卡驱动。")]),e._v(" "),t("h2",{attrs:{id:"入门"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#入门"}},[e._v("#")]),e._v(" 入门")]),e._v(" "),t("h3",{attrs:{id:"opengl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#opengl"}},[e._v("#")]),e._v(" OpenGL")]),e._v(" "),t("p",[e._v("Core-profile vs Immediate mode，Immediate mode是3.2版本之前的，固定函数管线，易于使用，但是不灵活，开发者不能控制计算过程。从3.2版本开始Core-profile，并弃用一些旧的功能。")]),e._v(" "),t("p",[e._v("使用现代API非常灵活和高效，但是更难学习。现代API需要开发者真正理解OpenGL和图形学编程。")]),e._v(" "),t("p",[e._v("OpenGL3.3版本包含了最核心的现代API功能，当前最新版本4.6")]),e._v(" "),t("p",[e._v("只有最新的显卡版本才支持比较新的OpenGL版本")]),e._v(" "),t("p",[e._v("OpenGL支持扩展，显卡公司将其实现在显卡驱动中，因此可以不用更新OpenGL版本就可以使用新特性。当一个扩展非常好用，很受欢迎，那很可能会出现在未来的OpenGL版本中。")]),e._v(" "),t("p",[e._v("OpenGL基本上是个大型的状态机器。")]),e._v(" "),t("blockquote",[t("p",[e._v("GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入")]),e._v(" "),t("p",[e._v("GLAD是一个OpenGL加载器，可以简化加载过程。")])]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("双缓冲(Double Buffer)")])]),e._v(" "),t("p",[e._v("应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。"),t("strong",[e._v("前")]),e._v("缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在"),t("strong",[e._v("后")]),e._v("缓冲上绘制。当所有的渲染指令执行完毕后，我们"),t("strong",[e._v("交换")]),e._v("(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。")])]),e._v(" "),t("h3",{attrs:{id:"你好、三角形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你好、三角形"}},[e._v("#")]),e._v(" 你好、三角形")]),e._v(" "),t("blockquote",[t("p",[e._v("几个重要概念：")]),e._v(" "),t("ul",[t("li",[e._v("顶点数组对象：Vertex Array Object，"),t("strong",[e._v("VAO")]),e._v("。用来保存顶点属性的配置信息（比如"),t("code",[e._v("glVertexAttribPointer")]),e._v("的参数、启用的顶点属性数组等），相当于"),t("strong",[e._v("顶点配置的 “快照”")]),e._v("，后续绘制时只需绑定 VAO，就能复用所有配置，不用重复设置。")]),e._v(" "),t("li",[e._v("顶点缓冲对象：Vertex Buffer Object，"),t("strong",[e._v("VBO")]),e._v("。GPU 中的一块内存区域，用来存储顶点数据（如坐标、颜色、纹理坐标等），目的是减少 CPU 和 GPU 之间的数据传输，提升性能。")]),e._v(" "),t("li",[e._v("元素缓冲对象：Element Buffer Object，"),t("strong",[e._v("EBO")]),e._v(" 或 索引缓冲对象 Index Buffer Object，IBO。它是 GPU 中的一块内存区域，专门用来存储"),t("strong",[e._v("顶点的索引数据")]),e._v("，解决顶点重复问题。")])])]),e._v(" "),t("p",[e._v("在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理的。")]),e._v(" "),t("p",[e._v("图形渲染管线接受一组3D坐标，并转变为屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。")]),e._v(" "),t("p",[e._v("OpenGL着色器使用GLSL写成的")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://stag-blog.oss-cn-beijing.aliyuncs.com/pipeline.png",alt:"pipeline"}})]),e._v(" "),t("blockquote",[t("p",[e._v("为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。")])]),e._v(" "),t("p",[e._v("图形渲染管线流程：")]),e._v(" "),t("ol",[t("li",[e._v("顶点数据：以数组形式传递三个3D坐标作为图跨渲染管线输入，用来表示一个三角形，这个数组叫顶点数组。")]),e._v(" "),t("li",[e._v("顶点着色器：把一个单独的顶点作为输入，把一种3D坐标转为另一种3D坐标？")]),e._v(" "),t("li",[e._v("几何着色器：将一组顶点作为输入，这些顶点形成图元，能够通过发出新的顶点来形成新的图元。")]),e._v(" "),t("li",[e._v("图元装配：将顶点着色器输出的所有顶点作为输入，并将所有点装配成指定图元的形状。")]),e._v(" "),t("li",[e._v("光栅化：把图元映射为最终屏幕上相应的像素，生成宫片段着色器使用的生成供片段着色器(Fragment Shader)使用的片段(Fragment)，在片段着色器运行之前会执行裁切(Clipping)，丢弃超出视图的所有像素。")]),e._v(" "),t("li",[e._v("片段着色器：计算一个像素的最终颜色，包含3D场景的数据（比如光照、阴影、光的颜色等等）。")]),e._v(" "),t("li",[e._v("测试与混合：检测片段对应的深度，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。")])]),e._v(" "),t("blockquote",[t("p",[e._v("OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。")]),e._v(" "),t("p",[t("strong",[e._v("标准化设备坐标(Normalized Device Coordinates, NDC)")]),e._v("：OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它，最终显示在屏幕上。")])]),e._v(" "),t("p",[e._v("OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）")])])}),[],!1,null,null,null);t.default=n.exports}}]);