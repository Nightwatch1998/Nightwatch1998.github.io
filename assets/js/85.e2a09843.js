(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{369:function(t,s,a){"use strict";a.r(s);var n=a(10),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"opengl学习"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#opengl学习"}},[t._v("#")]),t._v(" OpenGL学习")]),t._v(" "),s("p",[t._v("最好的OpenGL学习资料"),s("a",{attrs:{href:"https://learnopengl.com/Getting-started/OpenGL",target:"_blank",rel:"noopener noreferrer"}},[t._v("learnopengl"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/",target:"_blank",rel:"noopener noreferrer"}},[t._v("中文版地址"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("OpenGL是一组图形学接口，不同操作系统实现不同，具体的实现是由显卡制造商负责的，因此需要经常更新显卡驱动。")]),t._v(" "),s("h2",{attrs:{id:"入门"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#入门"}},[t._v("#")]),t._v(" 入门")]),t._v(" "),s("h3",{attrs:{id:"opengl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#opengl"}},[t._v("#")]),t._v(" OpenGL")]),t._v(" "),s("p",[t._v("Core-profile vs Immediate mode，Immediate mode是3.2版本之前的，固定函数管线，易于使用，但是不灵活，开发者不能控制计算过程。从3.2版本开始Core-profile，并弃用一些旧的功能。")]),t._v(" "),s("p",[t._v("使用现代API非常灵活和高效，但是更难学习。现代API需要开发者真正理解OpenGL和图形学编程。")]),t._v(" "),s("p",[t._v("OpenGL3.3版本包含了最核心的现代API功能，当前最新版本4.6")]),t._v(" "),s("p",[t._v("只有最新的显卡版本才支持比较新的OpenGL版本")]),t._v(" "),s("p",[t._v("OpenGL支持扩展，显卡公司将其实现在显卡驱动中，因此可以不用更新OpenGL版本就可以使用新特性。当一个扩展非常好用，很受欢迎，那很可能会出现在未来的OpenGL版本中。")]),t._v(" "),s("p",[t._v("OpenGL基本上是个大型的状态机器。")]),t._v(" "),s("blockquote",[s("p",[t._v("GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入")]),t._v(" "),s("p",[t._v("GLAD是一个OpenGL加载器，可以简化加载过程。")])]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("双缓冲(Double Buffer)")])]),t._v(" "),s("p",[t._v("应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。"),s("strong",[t._v("前")]),t._v("缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在"),s("strong",[t._v("后")]),t._v("缓冲上绘制。当所有的渲染指令执行完毕后，我们"),s("strong",[t._v("交换")]),t._v("(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。")])]),t._v(" "),s("h3",{attrs:{id:"你好、三角形"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你好、三角形"}},[t._v("#")]),t._v(" 你好、三角形")]),t._v(" "),s("blockquote",[s("p",[t._v("几个重要概念：")]),t._v(" "),s("ul",[s("li",[t._v("顶点数组对象：Vertex Array Object，"),s("strong",[t._v("VAO")]),t._v("。用来保存顶点属性的配置信息（比如"),s("code",[t._v("glVertexAttribPointer")]),t._v("的参数、启用的顶点属性数组等），相当于"),s("strong",[t._v("顶点配置的 “快照”")]),t._v("，后续绘制时只需绑定 VAO，就能复用所有配置，不用重复设置。")]),t._v(" "),s("li",[t._v("顶点缓冲对象：Vertex Buffer Object，"),s("strong",[t._v("VBO")]),t._v("。GPU 中的一块内存区域，用来存储顶点数据（如坐标、颜色、纹理坐标等），目的是减少 CPU 和 GPU 之间的数据传输，提升性能。")]),t._v(" "),s("li",[t._v("元素缓冲对象：Element Buffer Object，"),s("strong",[t._v("EBO")]),t._v(" 或 索引缓冲对象 Index Buffer Object，IBO。它是 GPU 中的一块内存区域，专门用来存储"),s("strong",[t._v("顶点的索引数据")]),t._v("，解决顶点重复问题。")])])]),t._v(" "),s("p",[t._v("在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理的。")]),t._v(" "),s("p",[t._v("图形渲染管线接受一组3D坐标，并转变为屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。")]),t._v(" "),s("p",[t._v("OpenGL着色器使用GLSL写成的")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://stag-blog.oss-cn-beijing.aliyuncs.com/pipeline.png",alt:"pipeline"}})]),t._v(" "),s("blockquote",[s("p",[t._v("为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。")])]),t._v(" "),s("p",[t._v("图形渲染管线流程：")]),t._v(" "),s("ol",[s("li",[t._v("顶点数据：以数组形式传递三个3D坐标作为图跨渲染管线输入，用来表示一个三角形，这个数组叫顶点数组。")]),t._v(" "),s("li",[t._v("顶点着色器：把一个单独的顶点作为输入，把一种3D坐标转为另一种3D坐标？")]),t._v(" "),s("li",[t._v("几何着色器：将一组顶点作为输入，这些顶点形成图元，能够通过发出新的顶点来形成新的图元。")]),t._v(" "),s("li",[t._v("图元装配：将顶点着色器输出的所有顶点作为输入，并将所有点装配成指定图元的形状。")]),t._v(" "),s("li",[t._v("光栅化：把图元映射为最终屏幕上相应的像素，生成宫片段着色器使用的生成供片段着色器(Fragment Shader)使用的片段(Fragment)，在片段着色器运行之前会执行裁切(Clipping)，丢弃超出视图的所有像素。")]),t._v(" "),s("li",[t._v("片段着色器：计算一个像素的最终颜色，包含3D场景的数据（比如光照、阴影、光的颜色等等）。")]),t._v(" "),s("li",[t._v("测试与混合：检测片段对应的深度，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。")])]),t._v(" "),s("blockquote",[s("p",[t._v("OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。")]),t._v(" "),s("p",[s("strong",[t._v("标准化设备坐标(Normalized Device Coordinates, NDC)")]),t._v("：OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它，最终显示在屏幕上。")])]),t._v(" "),s("p",[t._v("OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）")]),t._v(" "),s("h3",{attrs:{id:"着色器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#着色器"}},[t._v("#")]),t._v(" 着色器")]),t._v(" "),s("p",[t._v("着色器是使用一种叫GLSL的类C语言写成的。")]),t._v(" "),s("p",[t._v("着色器开头声明版本，输入变量、输出变量、uniform、main函数")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("version")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[t._v("version_number")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" type in_variable_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" type in_variable_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("out")]),t._v(" type out_variable_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uniform")]),t._v(" type uniform_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 处理输入并进行一些图形操作")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出处理过的结果到输出变量")]),t._v("\n  out_variable_name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" weird_stuff_we_processed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("GLSL默认基础数据类型：int、float、double、uint、bool")]),t._v(" "),s("p",[t._v("GLSL的向量是一个可以包含2、3、4个分量的容器，分量的类型可以是默认基础数据类型的一种")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("类型")]),t._v(" "),s("th",[t._v("含义")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("code",[t._v("vecn")])]),t._v(" "),s("td",[t._v("包含"),s("code",[t._v("n")]),t._v("个float分量的默认向量")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("bvecn")])]),t._v(" "),s("td",[t._v("包含"),s("code",[t._v("n")]),t._v("个bool分量的向量")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("ivecn")])]),t._v(" "),s("td",[t._v("包含"),s("code",[t._v("n")]),t._v("个int分量的向量")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("uvecn")])]),t._v(" "),s("td",[t._v("包含"),s("code",[t._v("n")]),t._v("个unsigned int分量的向量")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("dvecn")])]),t._v(" "),s("td",[t._v("包含"),s("code",[t._v("n")]),t._v("个double分量的向量")])])])]),t._v(" "),s("p",[t._v("重组：GLSL的向量可以灵活的重组")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec2")]),t._v(" someVec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" differentVec "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" someVec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("xyxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" anotherVec "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" differentVec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zyw"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" otherVec "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" someVec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("xxxx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" anotherVec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("yxzy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可。cool")]),t._v(" "),s("p",[t._v("向量作为参数：")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec2")]),t._v(" vect "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vect"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" otherResult "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("xyz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("输入与输出：GLSL定义了in和out关键字明确输入和输出，当有一个着色器的输出变量和下一个着色器阶段的输入匹配，就会传递下去。当类型和名字都一样时，OpenGL会把两个变量链接到一起，他们之间就能发送数据。")]),t._v(" "),s("p",[t._v("顶点着色器从顶点数据中直接接收。layout (location = 0) 表示查询位置属性 1可能代表颜色 等等")]),t._v(" "),s("p",[t._v("uniform是全局属性，全局意味着uniform变量必须在多个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。")]),t._v(" "),s("p",[t._v("使用uniform更新颜色")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('while(!glfwWindowShouldClose(window))\n{\n    // 输入\n    processInput(window);\n\n    // 渲染\n    // 清除颜色缓冲\n    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // 记得激活着色器\n    glUseProgram(shaderProgram);\n\n    // 更新uniform颜色\n    float timeValue = glfwGetTime();\n    float greenValue = sin(timeValue) / 2.0f + 0.5f;\n    int vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");\n    glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n\n    // 绘制三角形\n    glBindVertexArray(VAO);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    // 交换缓冲并查询IO事件\n    glfwSwapBuffers(window);\n    glfwPollEvents();\n}\n')])])]),s("p",[t._v("更多属性：")]),t._v(" "),s("p",[t._v("顶点数组包括了位置和顶点颜色")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("float vertices[] = {\n    // 位置              // 颜色\n     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下\n    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下\n     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部\n};\n")])])]),s("p",[t._v("顶点着色器：颜色变了位置属性为1")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("version")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("330")]),t._v(" core")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("layout")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("location "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" aPos"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 位置变量的属性位置值为 0 ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("layout")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("location "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" aColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 颜色变量的属性位置值为 1")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("out")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" ourColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 向片段着色器输出一个颜色")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    gl_Position "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("aPos"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    ourColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" aColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将ourColor设置为我们从顶点数据那里得到的输入颜色")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("片段着色器：")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("version")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("330")]),t._v(" core")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("out")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" FragColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" ourColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    FragColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ourColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("重新定义顶点指针，取颜色的时候注意步长属性、偏移量属性")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 位置属性\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n// 颜色属性\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));\nglEnableVertexAttribArray(1);\n")])])]),s("h3",{attrs:{id:"纹理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#纹理"}},[t._v("#")]),t._v(" 纹理")]),t._v(" "),s("p",[t._v("为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)。")]),t._v(" "),s("p",[t._v("纹理坐标的范围通常是从(0, 0)到(1, 1)")]),t._v(" "),s("p",[t._v("纹理环绕方式：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("环绕方式")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("GL_REPEAT")]),t._v(" "),s("td",[t._v("对纹理的默认行为。重复纹理图像。")])]),t._v(" "),s("tr",[s("td",[t._v("GL_MIRRORED_REPEAT")]),t._v(" "),s("td",[t._v("和GL_REPEAT一样，但每次重复图片是镜像放置的。")])]),t._v(" "),s("tr",[s("td",[t._v("GL_CLAMP_TO_EDGE")]),t._v(" "),s("td",[t._v("纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。")])]),t._v(" "),s("tr",[s("td",[t._v("GL_CLAMP_TO_BORDER")]),t._v(" "),s("td",[t._v("超出的坐标为用户指定的边缘颜色。")])])])]),t._v(" "),s("p",[t._v("纹理过滤：")]),t._v(" "),s("ul",[s("li",[t._v("GL_NEAREST 近邻过滤，有颗粒感")]),t._v(" "),s("li",[t._v("GL_LINEAR 线性过滤，更平滑")])]),t._v(" "),s("p",[t._v("放大和缩小操作可是设置不同的纹理过滤选项。")]),t._v(" "),s("p",[t._v("多级渐远纹理：它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。")]),t._v(" "),s("p",[t._v("在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。")]),t._v(" "),s("p",[t._v("多级渐远纹理主要是使用在纹理被缩小的情况下。")]),t._v(" "),s("p",[t._v("采样器(Sampler)：把纹理对象传给片段着色器")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("version")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("330")]),t._v(" core")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("out")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" FragColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec3")]),t._v(" ourColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec2")]),t._v(" TexCoord"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uniform")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sampler2D")]),t._v(" ourTexture"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    FragColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ourTexture"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" TexCoord"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("GLSL内部的texture函数返回一个纹理采样器，TexCoord是顶点的纹理坐标")]),t._v(" "),s("p",[t._v("将纹理颜色与顶点颜色混合")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[t._v("FragColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ourTexture"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" TexCoord"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ourColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);