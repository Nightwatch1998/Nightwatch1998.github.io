(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{372:function(t,s,a){"use strict";a.r(s);var n=a(10),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"learnopengl-04高级opengl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#learnopengl-04高级opengl"}},[t._v("#")]),t._v(" LearnOpenGL-04高级OpenGL")]),t._v(" "),s("h2",{attrs:{id:"深度测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深度测试"}},[t._v("#")]),t._v(" 深度测试")]),t._v(" "),s("h3",{attrs:{id:"深度缓冲"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深度缓冲"}},[t._v("#")]),t._v(" 深度缓冲")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("为什么需要深度缓冲？")])]),t._v(" "),s("p",[t._v("计算机屏幕是2D平面，但是我们要渲染3D场景。当多个像素在屏幕的同一坐标上重叠时，GPU需要判断，哪个像素离摄像机更近，应该显示出来；哪个更远，应该丢弃。")])]),t._v(" "),s("p",[t._v("深度缓冲：防止被阻挡的面渲染到其它面的前面，也叫"),s("strong",[t._v("Z缓冲")])]),t._v(" "),s("blockquote",[s("p",[t._v("Z缓冲：是一块与屏幕分辨率大小相同的显存区域，每个像素位置豆村出一个深度值。")]),t._v(" "),s("p",[t._v("数值范围：0.0-1.0,0.0表示离摄像头最近，1.0表示最远。")]),t._v(" "),s("p",[t._v("深度值在光栅化阶段计算，通常用"),s("strong",[t._v("16 位、24 位或 32 位的浮点数")]),t._v("存储。大部分系统是24位的。")])]),t._v(" "),s("h3",{attrs:{id:"深度测试-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深度测试-2"}},[t._v("#")]),t._v(" 深度测试")]),t._v(" "),s("p",[t._v("被启用时，OpenGL会将一个片段的深度值与深度缓冲的内容进行对比，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。")]),t._v(" "),s("p",[t._v("启用深度测试：")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glEnable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_DEPTH_TEST"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("清楚上次渲染迭代中写入的深度值：")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glClear")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_COLOR_BUFFER_BIT "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" GL_DEPTH_BUFFER_BIT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("不更新深度缓冲")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glDepthMask")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_FALSE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"深度测试函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深度测试函数"}},[t._v("#")]),t._v(" 深度测试函数")]),t._v(" "),s("p",[t._v("OpenGL允许我们修改深度测试中使用的比较运算符。")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glDepthFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_LESS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("table",[s("thead",[s("tr",[s("th",[t._v("函数")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("GL_ALWAYS")]),t._v(" "),s("td",[t._v("永远通过深度测试")])]),t._v(" "),s("tr",[s("td",[t._v("GL_NEVER")]),t._v(" "),s("td",[t._v("永远不通过深度测试")])]),t._v(" "),s("tr",[s("td",[t._v("GL_LESS")]),t._v(" "),s("td",[t._v("在片段深度值小于缓冲的深度值时通过测试")])]),t._v(" "),s("tr",[s("td",[t._v("GL_EQUAL")]),t._v(" "),s("td",[t._v("在片段深度值等于缓冲区的深度值时通过测试")])]),t._v(" "),s("tr",[s("td",[t._v("GL_LEQUAL")]),t._v(" "),s("td",[t._v("在片段深度值小于等于缓冲区的深度值时通过测试")])]),t._v(" "),s("tr",[s("td",[t._v("GL_GREATER")]),t._v(" "),s("td",[t._v("在片段深度值大于缓冲区的深度值时通过测试")])]),t._v(" "),s("tr",[s("td",[t._v("GL_NOTEQUAL")]),t._v(" "),s("td",[t._v("在片段深度值不等于缓冲区的深度值时通过测试")])]),t._v(" "),s("tr",[s("td",[t._v("GL_GEQUAL")]),t._v(" "),s("td",[t._v("在片段深度值大于等于缓冲区的深度值时通过测试")])])])]),t._v(" "),s("h3",{attrs:{id:"深度值精度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深度值精度"}},[t._v("#")]),t._v(" 深度值精度")]),t._v(" "),s("p",[t._v("线性深度缓冲：")]),t._v(" "),s("blockquote",[s("p",[t._v("$$\n\\begin{equation} F_{depth} = \\frac{z - near}{far - near} \\end{equation}\n$$")]),t._v(" "),s("p",[t._v("z是观察空间中介于near和far之间的值，需要映射为[0,1]之间的范围。")])]),t._v(" "),s("p",[s("strong",[t._v("它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。")])]),t._v(" "),s("p",[t._v("非线性深度缓冲:")]),t._v(" "),s("blockquote",[s("p",[t._v("$$\n\\begin{equation} F_{depth} = \\frac{1/z - 1/near}{1/far - 1/near} \\end{equation}\n$$")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://stag-blog.oss-cn-beijing.aliyuncs.com/depth_non_linear_graph.png",alt:"depth_non_linear_graph"}})]),t._v(" "),s("h3",{attrs:{id:"深度冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深度冲突"}},[t._v("#")]),t._v(" 深度冲突")]),t._v(" "),s("p",[t._v("在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。")]),t._v(" "),s("h3",{attrs:{id:"防止深度冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#防止深度冲突"}},[t._v("#")]),t._v(" 防止深度冲突")]),t._v(" "),s("p",[t._v("深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显")]),t._v(" "),s("ul",[s("li",[t._v("永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。")]),t._v(" "),s("li",[t._v("尽可能将近平面设置远一些")]),t._v(" "),s("li",[t._v("使用更高精度的深度缓冲")])]),t._v(" "),s("h2",{attrs:{id:"模板测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板测试"}},[t._v("#")]),t._v(" 模板测试")]),t._v(" "),s("h3",{attrs:{id:"模板缓冲"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板缓冲"}},[t._v("#")]),t._v(" 模板缓冲")]),t._v(" "),s("p",[t._v("每个模板值(Stencil Value)是8位的，每个像素有256中模板值，根据模板值来确定是否丢弃或保留片段。")]),t._v(" "),s("p",[t._v("存储每个像素的整数标记值，是控制绘制区域的 “蒙版”，核心作用是标记像素、限制绘制范围。")]),t._v(" "),s("p",[t._v("主要用来实现阴影、镜面、镂空、轮廓描边等特效。")]),t._v(" "),s("blockquote",[s("p",[t._v("模板缓冲是一块"),s("strong",[t._v("与屏幕分辨率大小相同的显存区域")]),t._v("，每个像素位置存储一个"),s("strong",[t._v("整数值")]),t._v("（通常是 8 位，取值 0~255）。它的作用就像一张 "),s("strong",[t._v("“模板蒙版”")]),t._v("，可以为屏幕上的每个像素打上 “标记”，后续渲染时根据这个标记决定是否绘制该像素。")])]),t._v(" "),s("h3",{attrs:{id:"模板测试-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板测试-2"}},[t._v("#")]),t._v(" 模板测试")]),t._v(" "),s("p",[t._v("当片段着色器处理完一个片段后，模板测试可是执行，可能会丢弃片段，之后深度测试会执行。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://stag-blog.oss-cn-beijing.aliyuncs.com/stencil_buffer.png",alt:"stencil_buffer"}})]),t._v(" "),s("p",[t._v("模板缓冲大体步骤：")]),t._v(" "),s("ul",[s("li",[t._v("启用模板缓冲的写入。")]),t._v(" "),s("li",[t._v("渲染物体，更新模板缓冲的内容。")]),t._v(" "),s("li",[t._v("禁用模板缓冲的写入。")]),t._v(" "),s("li",[t._v("渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。")])]),t._v(" "),s("p",[t._v("启用模板缓冲")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glEnable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_STENCIL_TEST"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("每次迭代前清除模板缓冲")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glClear")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_COLOR_BUFFER_BIT "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" GL_DEPTH_BUFFER_BIT "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" GL_STENCIL_BUFFER_BIT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("控制模板缓冲的写入权限")])]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilMask")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 允许写入模板缓冲（默认值")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilMask")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 禁止写入模板缓冲（后续操作不会修改模板值）")]),t._v("\n")])])]),s("h3",{attrs:{id:"模板缓冲函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板缓冲函数"}},[t._v("#")]),t._v(" 模板缓冲函数")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_EQUAL"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[s("strong",[t._v("模板测试判断规则：")])]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GLenum func"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GLint ref"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GLuint mask"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[s("p",[s("code",[t._v("func")]),t._v("：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的"),s("code",[t._v("ref")]),t._v("值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("ref")]),t._v("：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("mask")]),t._v("：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。")])])]),t._v(" "),s("p",[s("strong",[t._v("定义模板测试+深度测试后，模板缓冲值的修改规则：")])]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilOp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GLenum sfail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GLenum dpfail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GLenum dppass"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[s("code",[t._v("sfail")]),t._v("：模板测试失败时采取的行为。")]),t._v(" "),s("li",[s("code",[t._v("dpfail")]),t._v("：模板测试通过，但深度测试失败时采取的行为。")]),t._v(" "),s("li",[s("code",[t._v("dppass")]),t._v("：模板测试和深度测试都通过时采取的行为。")])]),t._v(" "),s("p",[t._v("每个选项都可以选用以下一种行为。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("行为")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("GL_KEEP")]),t._v(" "),s("td",[t._v("保持当前储存的模板值")])]),t._v(" "),s("tr",[s("td",[t._v("GL_ZERO")]),t._v(" "),s("td",[t._v("将模板值设置为0")])]),t._v(" "),s("tr",[s("td",[t._v("GL_REPLACE")]),t._v(" "),s("td",[t._v("将模板值设置为glStencilFunc函数设置的"),s("code",[t._v("ref")]),t._v("值")])]),t._v(" "),s("tr",[s("td",[t._v("GL_INCR")]),t._v(" "),s("td",[t._v("如果模板值小于最大值则将模板值加1")])]),t._v(" "),s("tr",[s("td",[t._v("GL_INCR_WRAP")]),t._v(" "),s("td",[t._v("与GL_INCR一样，但如果模板值超过了最大值则归零")])]),t._v(" "),s("tr",[s("td",[t._v("GL_DECR")]),t._v(" "),s("td",[t._v("如果模板值大于最小值则将模板值减1")])]),t._v(" "),s("tr",[s("td",[t._v("GL_DECR_WRAP")]),t._v(" "),s("td",[t._v("与GL_DECR一样，但如果模板值小于0则将其设置为最大值")])]),t._v(" "),s("tr",[s("td",[t._v("GL_INVERT")]),t._v(" "),s("td",[t._v("按位翻转当前的模板缓冲值")])])])]),t._v(" "),s("h3",{attrs:{id:"物体轮廓"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#物体轮廓"}},[t._v("#")]),t._v(" 物体轮廓")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://stag-blog.oss-cn-beijing.aliyuncs.com/stencil_object_outlining.png",alt:"stencil_object_outlining"}})]),t._v(" "),s("p",[t._v("为物体创建轮廓的步骤：")]),t._v(" "),s("ol",[s("li",[t._v("启用模板写入。")]),t._v(" "),s("li",[t._v("在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。")]),t._v(" "),s("li",[t._v("渲染物体。")]),t._v(" "),s("li",[t._v("禁用模板写入以及深度测试。")]),t._v(" "),s("li",[t._v("将每个物体放大一点点。")]),t._v(" "),s("li",[t._v("使用一个不同的片段着色器，输出一个单独的（边框）颜色。")]),t._v(" "),s("li",[t._v("再次绘制物体，但只在它们片段的模板值不等于1时才绘制。")]),t._v(" "),s("li",[t._v("再次启用模板写入和深度测试。")])]),t._v(" "),s("p",[t._v("第一步，绘制模型")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glEnable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_STENCIL_TEST"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_ALWAYS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 总是通过测试，参考值设为1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilOp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_KEEP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_KEEP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_REPLACE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 测试通过时，用1替换模板缓冲值")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilMask")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 允许写入模板缓冲（0xFF表示全部位可写）")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 绘制原始模型：此时模型覆盖的像素的模板缓冲值会被设为1，其他像素为0")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("DrawModel")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilMask")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 禁止写入模板缓冲（后续操作不修改模板值）")]),t._v("\n")])])]),s("p",[t._v("第二步，放大模型")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_NOTEQUAL"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 模板值不等于1时，测试通过")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glStencilOp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_KEEP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_KEEP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_KEEP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不修改模板缓冲值")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 绘制放大后的模型（用黑色）：此时只有模板值为0的区域（模型外）会被绘制，形成轮廓")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("DrawScaledModel")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Color")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glDisable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_STENCIL_TEST"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 禁用模板测试")]),t._v("\n")])])]),s("h2",{attrs:{id:"混合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合"}},[t._v("#")]),t._v(" 混合")]),t._v(" "),s("p",[t._v("在片段着色器中，如果一个片段的alpha值低于某个阈值，就丢弃片段")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("version")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("330")]),t._v(" core")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("out")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" FragColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec2")]),t._v(" TexCoords"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uniform")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sampler2D")]),t._v(" texture1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("             \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" texColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("texture1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" TexCoords"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("texColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("discard")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    FragColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" texColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("当需要渲染多个半透明图像时，就需要混合。")]),t._v(" "),s("p",[t._v("$$\n\\begin{equation}\\bar{C}"),s("em",[t._v("{result} = \\bar{\\color{green}C}")]),t._v("{source} * \\color{green}F_{source} + \\bar{\\color{red}C}"),s("em",[t._v("{destination} * \\color{red}F")]),t._v("{destination}\\end{equation}\n$$\n混合颜色=源颜色向量"),s("em",[t._v("源因子值+目标颜色向量")]),t._v("目标因子值。")]),t._v(" "),s("p",[t._v("让绿色正方形绘制在红色之上\n$$\n\\begin{equation}\\bar{C}_{result} = \\begin{pmatrix} \\color{red}{0.0} \\ \\color{green}{1.0} \\ \\color{blue}{0.0} \\ \\color{purple}{0.6} \\end{pmatrix} * \\color{green}{0.6} + \\begin{pmatrix} \\color{red}{1.0} \\ \\color{green}{0.0} \\ \\color{blue}{0.0} \\ \\color{purple}{1.0} \\end{pmatrix} * (\\color{red}{1 - 0.6}) \\end{equation}\n$$\n"),s("img",{attrs:{src:"https://stag-blog.oss-cn-beijing.aliyuncs.com/blending_equation_mixed.png",alt:"blending_equation_mixed"}})]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glBlendFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GLenum sfactor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GLenum dfactor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("可选项：GL_ZERO、GL_ONE、GL_SRC_COLOR、GL_ONE_MINUS_SRC_COLOR、GL_DST_COLOR等等")]),t._v(" "),s("h3",{attrs:{id:"混合函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合函数"}},[t._v("#")]),t._v(" 混合函数")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glBlendFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_SRC_ALPHA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_ONE_MINUS_SRC_ALPHA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("为RGB和Alpha设置不同的选项：")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glBlendFuncSeparate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_SRC_ALPHA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_ONE_MINUS_SRC_ALPHA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_ONE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_ZERO"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("设置Alpha通道运算符")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glBlendEquation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GLenum mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[t._v("GL_FUNC_ADD：默认选项，将两个分量相加")]),t._v(" "),s("li",[t._v("GL_FUNC_SUBTRACT：将两个分量相减")]),t._v(" "),s("li",[t._v("GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反")]),t._v(" "),s("li",[t._v("GL_MIN：取两个分量中的最小值")]),t._v(" "),s("li",[t._v("GL_MAX：取两个分量中的最大值")])]),t._v(" "),s("h3",{attrs:{id:"渲染半透明纹理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染半透明纹理"}},[t._v("#")]),t._v(" 渲染半透明纹理")]),t._v(" "),s("p",[t._v("设定混合参数")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glEnable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_BLEND"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glBlendFunc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_SRC_ALPHA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_ONE_MINUS_SRC_ALPHA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("不用丢弃片段了")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("version")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("330")]),t._v(" core")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("out")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec4")]),t._v(" FragColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("vec2")]),t._v(" TexCoords"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("uniform")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sampler2D")]),t._v(" texture1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("             \n    FragColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("texture1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" TexCoords"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。")]),t._v(" "),s("p",[t._v("要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。")]),t._v(" "),s("p",[t._v("当绘制一个有不透明和透明物体的场景的时候：")]),t._v(" "),s("ol",[s("li",[t._v("先绘制所有不透明的物体。")]),t._v(" "),s("li",[t._v("对所有透明的物体排序。")]),t._v(" "),s("li",[t._v("按顺序绘制所有透明的物体。")])]),t._v(" "),s("p",[t._v("在场景中排序物体是一个很困难的技术，很大程度上由你场景的类型所决定，更别说它额外需要消耗的处理能力了。完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有"),s("strong",[t._v("次序无关透明度")]),t._v("。")])])}),[],!1,null,null,null);s.default=e.exports}}]);